---
import { getLangFromUrl, useTranslations } from "../i18n/utils"

const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

import unit1 from '../assets/images/bugs/libellula.svg?url';
import unit2 from '../assets/images/bugs/bombo.svg?url';
import unit3 from '../assets/images/bugs/coccinella.svg?url';

import arrow from '../assets/images/arrow.svg?url';
---

<div class="container" id="business-units">
  <div class="deck" role="list">
    <div class="unit" id="u1" role="listitem">
      <div class="icon">
        <img src={unit1} />
      </div>
      <div class="text">
        <h3>{t('bu.u1.title')}</h3>
        <p>{t('bu.u1.description')}</p>
      </div>
    </div>
    
    <div class="unit" id="u2" role="listitem">
      <div class="icon">
        <img src={unit2} />
      </div>
      <div class="text">
        <h3>{t('bu.u2.title')}</h3>
        <p>{t('bu.u2.description')}</p>
      </div>
    </div>
    
    <div class="unit" id="u3" role="listitem">
      <div class="icon">
        <img src={unit3} />
      </div>
      <div class="text">
        <h3>{t('bu.u3.title')}</h3>
        <p>{t('bu.u3.description')}</p>
      </div>
    </div>
  </div>
  
  <button id="arrow" aria-label="Prossima unit" class="arrow-btn">
    <img src={arrow} alt="" />
  </button>
</div>

<style lang="scss">
  @use '../assets/style/main.scss' as vars;
  
  // parametri per gestire comportamento deck
  $deck-width: 100%;
  $deck-height: 520px;
  $stack-gap: 48px;
  $scale-step: 0.04;
  $opacity-step: 0.14;
  $units-visible: 3;
  
  .container {
    position: relative;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: $deck-height;
  }
  
  .deck {
    position: relative;
    width: min($deck-width, vars.$bp-medium);
    height: $deck-height;
    /* flag letta da JS per capire se siamo in modalità stacked */
    --stack-mode: 0;
  }
  
  .unit {
    position: absolute;
    left: 40%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 60%;
    height: $deck-height;
    display: flex;
    flex-direction: column;
    color: white;
    padding: 0 40px;
    
    transition: transform 360ms cubic-bezier(.2,.9,.2,1), opacity 360ms ease;
    transform-origin: center center;
    pointer-events: none;
    border-radius: 6px;
    
    p, h3 {
      opacity: 0;
    }
  }
  
  #u1 { background-color: vars.$color-green; }
  #u2 { background-color: vars.$color-yellow; }
  #u3 { background-color: vars.$color-orange; }
  
  .icon {
    width: 130px;
    height: 130px;
    border-radius: 100%;
    background-color: vars.$color-gray;
    position: absolute;
    top: -20px;
    opacity: 0;
    
    img {
      position: absolute;
      width: 80%;
      height: 80%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  }
  
  h3 {
    margin-top: 130px;
    margin-bottom: 20px;
  }
  
  p {
    margin: 0;
    line-height: 1.25;
  }
  
  .arrow-btn {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    background: transparent;
    border: none;
    padding: 8px;
    cursor: pointer;
    z-index: 999;
  }
  
  .arrow-btn img {
    width: 40px;
    height: auto;
    transform: scaleY(1.8);
    filter: invert(1);
  }
  
  /* solo la card front riceve eventi */
  .unit.front {
    pointer-events: auto;
    .icon, h3, p {
      opacity: 1;
    }
  }
  
  /* ---------- Cambiamento: stacked quando la viewport è >= bp-medium ---------- */
  @media screen and (min-width: vars.$bp-medium) {
    /* in modalità "over small" nascondi freccia (se vuoi conservarla rimuovi questa riga) */
    #arrow {
      display: none;
    }
    
    .container {
      height: unset;
      width: 100%;
      padding: 0px;
    }
    
    .deck {
      width: 100%;
      display: flex;
      flex-direction: column;
      /* attiva la modalità stacked per JS */
      --stack-mode: 1;
      height: unset;
    }
    
    .unit {
      width: 100%;
      height: 270px;
      position: relative;
      pointer-events: auto;
      left: 0%;
      top: 0%;
      transform: translate(0, 0);
      border-radius: 0;
      transition: none;
      p, h3, .icon {
        opacity: 1;
      }
      display: flex;
      flex-direction: row;
      justify-content: space-around;
      padding: 0;
    }
    
    #u2 {
      flex-direction: row-reverse;
      .icon img {
        transform: translateX(-5%);
      }
    }
    
    .icon {
      align-self: center;
      position: relative;
      height: 200px;
      width: 200px;
      top: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      flex: 0 0 200px;
      min-width: 200px;
      min-height: 200px;
      overflow: hidden;
      border-radius: 100%;
      background-color: vars.$color-gray;
      justify-content: space-around;
      
      img {
        position: relative;
        top: 0;
        left: 0;
        transform: translate(0, 0);
        width: 70%;
        height: 70%;
        object-fit: contain;
      }
    }
    
    .text {
      padding-top: 60px;
      max-width: 70%;
    }
    
    h3 {
      margin: 0px 0 20px 0;
    }
  }
  
</style>

<script type="module">
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('#business-units');
    if (!container) return;
    
    const deck = container.querySelector('.deck');
    const units = Array.from(deck.querySelectorAll('.unit'));
    const btn = container.querySelector('#arrow');
    const n = units.length;
    if (n === 0 || !btn) return;
    
    const GAP = 48; // deve rimanere coerente con $stack-gap
    const OPACITY_STEP = 0.14;
    
    let current = 0; // indice della card in primo piano
    
    // now detect stack mode reading the CSS custom property
    function isStackMode() {
      const val = getComputedStyle(deck).getPropertyValue('--stack-mode').trim();
      return val === '1';
    }
    
    function clearInlineStyles() {
      units.forEach(el => {
        el.style.transform = '';
        el.style.opacity = '';
        el.style.zIndex = '';
        el.classList.remove('front');
      });
    }
    
    function render() {
      // se siamo in modalità responsive (stack sul CSS), non sovrascriviamo il layout
      if (isStackMode()) {
        clearInlineStyles();
        console.debug('[BU] render: stack-mode ON — cleared inline styles');
        return;
      }
      console.debug('[BU] render: stack-mode OFF — applying transforms, current=', current);
      
      const viewportWidth = window.innerWidth;
      const deckWidth = Math.min(768, viewportWidth);
      const maxOffset = deckWidth * 0.18; // Limita lo spostamento orizzontale al 15% della larghezza del deck
      
      units.forEach((el, i) => {
        const rel = (i - current + n) % n;
        const translateX = Math.min(rel * GAP, maxOffset); // Limita lo spostamento massimo
        const opacity = Math.max(0, 1 - rel * OPACITY_STEP);
        el.style.zIndex = String(n - rel);
        el.style.transform = `translate(-50%, -50%) translateX(${translateX}px)`;
        el.style.opacity = String(opacity);
        if (rel === 0) {
          el.classList.add('front');
        } else {
          el.classList.remove('front');
        }
      });
    }
    
    function next() {
      current = (current + 1) % n;
      render();
    }
    
    // Init
    render();
    
    // Eventi
    btn.addEventListener('click', next);
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); next(); }, { passive: false });
    
    // aggiorna su resize/orientation (quando cambia breakpoint)
    window.addEventListener('resize', render);
    window.addEventListener('orientationchange', render);
  });
</script>